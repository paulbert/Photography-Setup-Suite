(function() {
	angular.module('listMod')
	.service('listFunctions', ['$q','filterFunctions',function ($q,filterFunctions) {
		
		var lFunc = this,
			editList = [],
			currentFilteredList = [];			
		
		this.Lists = {};
		this.orderSavePending = false;
		
		this.setList = function(listArray,listName,excludeArray) {
			this.Lists[listName] = { main:listArray,selected:[],edit:[],filtered:[],exclude:excludeArray,sections:[''] };
			var mainArray = this.Lists[listName].main,
				sectionArray = this.Lists[listName].sections;
			for(var i = 0; i < mainArray.length; i++) {
				if(mainArray[i].section && sectionArray.indexOf(mainArray[i].section) === -1) {
					sectionArray.push(mainArray[i].section);
				}
			}
		};
		
		this.clearSelected = function(listName) {
			this.Lists[listName].selected = [];
		};
		
		this.checkSelected = function(listName) {
			return this.Lists[listName].selected.length === 0;
		};
		
		this.listLength = function(listName,subList) {
			subList = typeof subList !== 'undefined' ? subList : 'main';
			if(this.Lists[listName]) {
				return this.Lists[listName][subList].length;
			} else {
				return 0;
			}
		};
		
		// Copies the selected list over to the edit list (for 'edit selected' situations)
		this.selectToEdit = function(listName) {
			this.Lists[listName].edit = this.Lists[listName].selected;
		};
		
		this.editOne = function(id,listName,idName) {
			var index = this.findById(id,listName,idName);
			this.Lists[listName].edit = [];
			this.Lists[listName].edit.push(this.Lists[listName].main[index]);
		};
		
		// First checks exclude array for item, then checks search value (see filterService.js)
		this.filterCheck = function(value,index,search,keyName,listName) {
			var listCheck = false,
				showItem = false;
			listCheck = lFunc.findById(value[keyName],listName,keyName,'exclude');
			if(listCheck === false) {
				showItem = filterFunctions.filterCheck(value,search);
				// Deselect item if the filter excludes the item
				if(value.selected && !showItem && index >= 0) {
					lFunc.deselectItem(value[keyName],index,keyName,listName);
				}
			}
			lFunc.setFiltered(listName,index,showItem);
			return showItem;
		};
		
		// Adds property with filter status of element
		this.setFiltered = function(listName,index,show) {
			this.Lists[listName].main[index].showItem = show;
		};
		
		// Creates a list of only the currently filtered elements of the main array. Returns this filtered array.
		this.setFilterArray = function(listName) {
			var mainArray = this.Lists[listName].main;
			for(var i = 0; i < mainArray.length; i++) {
				if(mainArray[i].showItem === true) {
					this.Lists[listName].filtered.push(mainArray[i]);
				}
			}
			return this.Lists[listName].filtered;
		};
		
		// Toggle selection of item - changes select property of item between true/false and adds/removes from selection array
		// Optional selectOne: if true all items will be deselected first so only one item is selected at a time 
		// NOTE: index parameter is changed to fallback in case id not found
		this.toggleSelect = function(item,index,key,listName,selectOne) {
			key = key ? key : 'id';
			var id = item[key];
			var idIndex = this.findById(id,listName,key,'main');
			if(selectOne) {
				this.deselectAll(key,listName);
			}
			if(!item.selected) {
				this.selectItem(item,idIndex || index,key,listName);
			} else {
				this.deselectItem(id,idIndex || index,key,listName);
			}
		};

		// Function to create a comma separated list of a particular property within one of the lists. keyName specifies property to use (name of the item, generally). 
		this.makeList = function(listName,keyName,subList) {
			if(!subList) {
				subList = 'main';
			}
			var listArray = this.Lists[listName][subList],
				message = '';
			for(var i = 0; i < listArray.length; i++) {
				message += listArray[i][keyName];
				if(i < listArray.length - 1) {
					message += ', ';
				}
			}
			return message;
		};

		// Returns the index of the item within the an array (specified by listName and subList) or false if not found.  Search by key (should be unique id).
		this.findById = function(id,listName,key,subList) {
			key = typeof key !== 'undefined' ? key : 'id';
			subList = typeof subList !== 'undefined' ? subList : 'main';
			var listArray = this.Lists[listName][subList];
			for(var i = 0; i < listArray.length; i++) {
				if(String(listArray[i][key]) === String(id)) {
					return i;
				}			
			}
			return false;
		};
		
		// Finish a delete by id on the main list by clearing the sublists as well
		var finishDelete = function(listName,subList) {
			var list = lFunc.Lists[listName][subList];
			for(var i = list.length - 1; i > -1; i--) {
				if(list[i].delete) {
					list.splice(i,1);
				}
			}
		};
		
		// Deletes items found in delArray from main list searching by id. Does nothing with items which are not found.
		this.deleteById = function(delArray,idName,listName,subList) {
			var numItems = delArray.length;
			subList = typeof subList !== 'undefined' ? subList : 'main';
			for(var i = 0; i < numItems; i++) {
				var imgIndex = lFunc.findById(delArray[i][idName],listName,idName,subList);
				if(imgIndex !== false) {
					if(subList === 'main') {
						lFunc.Lists[listName][subList][imgIndex].delete = true;
					}
					lFunc.Lists[listName][subList].splice(imgIndex,1);
				}
			}
			var subLists = [];
			if(subList === 'main') {
				subLists = [ 'selected', 'filtered', 'edit' ];
			}
			for(i = 0; i < subLists.length; i++) {
				finishDelete(listName,subLists[i]);
			}
		};
		
		// Selects all items within the current filter set
		this.selectAll = function(key,listName) {
			key = typeof key !== 'undefined' ? key : 'id';
			var filteredItems = this.setFilterArray(listName);
			var numItems = filteredItems.length;
			for(var i = 0; i < numItems; i++) {
				if(!filteredItems[i].selected) {
					lFunc.selectItem(filteredItems[i],undefined,key,listName);
				}
			}
		};
		
		// Deselects all items
		this.deselectAll = function(key,listName) {
			key = typeof key !== 'undefined' ? key : 'id';
			var numPhotos = this.Lists[listName].main.length;
			if(!this.checkSelected(listName)) {
				for(var i = 0; i < numPhotos; i++) {
					var item = this.Lists[listName].main[i];
					if(item.selected) {
						this.deselectItem(item.id,i,key,listName);
					}
				}
			}
		};
		
		this.deselectItem = function(id,index,key,listName) {
			key = typeof key !== 'undefined' ? key : 'id';
			lFunc.Lists[listName].main[index].selected = false;
			var selIndex = lFunc.findById(id,listName,key,'selected');
			lFunc.Lists[listName].selected.splice(selIndex,1);
		};

		this.selectItem = function(item,index,key,listName) {
			key = typeof key !== 'undefined' ? key : 'id';
			if(!index) {
				index = this.findById(item[key],listName,key,'main');
			}
			this.Lists[listName].main[index].selected = true;
			this.Lists[listName].selected.push(item);
		};
		
		// After items are moved in list, sets the order value (named ordKey) to the correct number for the DB.  Also adds order and section to the selected list.
		var resetOrder = function(key,ordKey,listName,section) {
			var selIndex = 0;
			for(i = 0; i < lFunc.Lists[listName].main.length; i++) {
				lFunc.Lists[listName].main[i][ordKey] = i;
				if(lFunc.Lists[listName].main.selected) {
					selIndex = lFunc.findById(lFunc.Lists[listName].main[i][key],listName,key,'selected');
					lFunc.Lists[listName].selected[selIndex][ordKey] = i;
					if(typeof section !== 'undefined') {
						lFunc.Lists[listName].selected[selIndex].section = section;
					}
				}
			}
		};
		
		// Adds the selected items to a section and reorders items to group those together.
		this.groupSelected = function(key,ordKey,section,listName) {
			var listTemp = lFunc.Lists[listName].main,
				firstIndex = -1,
				moveIndex = 0,
				selIndex;
			for(var i = 0; i < listTemp.length; i++) {
				if(listTemp[i].selected || listTemp[i].section === section) {
					if(firstIndex === -1) {
						firstIndex = i;
						listTemp[i].section = section;
					} else {
						moveIndex = i;
						listTemp[moveIndex].section = section;
						listTemp.splice(firstIndex+1,0,listTemp.splice(moveIndex,1)[0]);
						firstIndex++;
					}
				}
			}
			lFunc.Lists[listName].main = listTemp;
			resetOrder(key,ordKey,listName,section);
		};
		
		// Moves one item.  Checks the sections of the items to ensure items within same section stick together.
		var selectedIdArray = function(key,listName) {
			return lFunc.Lists[listName].selected.map(function(val) { return val[key]; });
		};
		
		// Moves selected items or one item as specified by id.  Checks the sections of the items to ensure items within same section stick together.
		this.moveItems = function(direction,key,ordKey,listName,id) {
			var selSection = null,
				listLen = lFunc.Lists[listName].main.length,
				multiplier,
				nextSection,
				idArray;
				
			if(id) {
				idArray = [id];
			} else {
				idArray = selectedIdArray(key,listName);
			}
			
			var i = direction > 0 ? listLen - 1 : 0;
			// Loop through main list opposite the direction of the movement of items to make sure order is otherwise preserved.
			for(i; i < listLen && i >= 0; i = i - direction) {
				multiplier = 1;
				// If the item is in the selected list or the section is moving.
				if(idArray.indexOf(lFunc.Lists[listName].main[i][key]) !== -1 || lFunc.Lists[listName].main[i].section === selSection) {
					// Set selSection to section of a selected item.
					if(lFunc.Lists[listName].main[i].section) {
						selSection = lFunc.Lists[listName].main[i].section;
					}
					// If the movement would put the item outside of list boundaries or another selection has hit those boundaries don't move.
					if(i+direction >= 0 && i+direction < listLen && !lFunc.Lists[listName].main[i+direction].selected) {
						// If the next item is in a defined section, need to check & count items in section to jump over or stop movement.
						if(lFunc.Lists[listName].main[i+direction].section !== '' && lFunc.Lists[listName].main[i].section !== lFunc.Lists[listName].main[i+direction].section) {
							nextSection = lFunc.Lists[listName].main[i+direction].section;
							multiplier = 0;
							// Loop back through array in the direction of movement.
							for(var j = i + direction; j < listLen && j >= 0; j = j + direction) {
								// If the item is in the section...
								if(lFunc.Lists[listName].main[j].section === nextSection) {
									// If selected stop movement and break.
									if(lFunc.Lists[listName].main[j].selected) {
										multiplier = 0;
										break;
									}
									// If not, count section.
									multiplier++;
								} else {
									// Break loop at first item not in section.
									break;
								}
							}
						}
						lFunc.Lists[listName].main.splice(i+(direction*multiplier),0,lFunc.Lists[listName].main.splice(i,1)[0]);
					}
				}
			}
			// Reset order variable for database.
			resetOrder(key,ordKey,listName);
		};
		
		this.setOrderSave = function(orderSave) {
			this.orderSavePending = orderSave ? orderSave : false;
		};
		
		this.toggleFlag = function(id,listName,idName,toggleName,unique) {
			var thisList = this.Lists[listName].main;
			for(var i = 0; i < thisList.length; i++) {
				if(thisList[i][idName] === id) {
					thisList[i][toggleName] = '1';
				} else {
					if(unique) {
						thisList[i][toggleName] = '0';
					}
				}
			}
		};
		
		this.addToSections = function(section,listName) {
			this.Lists[listName].sections.push(section);
		};
		
		this.makeTempId = function(listName,idName,tempId) {
			if(this.findById(tempId,listName,idName) === false) {
				return tempId;
			}
			return this.makeTempId(listName,idName,tempId + 1);
		};	
	}]);
})();